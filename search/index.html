<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="generator" content="Jekyll v3.3.1">

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		<link type="application/atom+xml" rel="alternate" href="https://mde-optimiser.github.io/feed.xml" title="MDEOptimiser" />
		<!-- Begin Jekyll SEO tag v2.0.0 -->
<title>Search - MDEOptimiser</title>
<meta property="og:title" content="Search" />
<meta name="description" content="Tool documentation website for MDEOptimiser." />
<meta property="og:description" content="Tool documentation website for MDEOptimiser." />
<link rel="canonical" href="https://mde-optimiser.github.io/search/" />
<meta property="og:url" content="https://mde-optimiser.github.io/search/" />
<meta property="og:site_name" content="MDEOptimiser" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "WebPage",
    "headline": "Search",
    "description": "Tool documentation website for MDEOptimiser.",
    "logo": "https://mde-optimiser.github.io/siteicon.png",
    "url": "https://mde-optimiser.github.io/search/"
  }
</script>
<!-- End Jekyll SEO tag -->

		
	</head>

	<body>
		<header>
			<h1>
				<a href="/"><img src="/images/siteicon.png" width="40" height="40" alt="MDEOptimiser logo"></a>
				MDEOptimiser
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav class="full-navigation">
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/">MDEOptimiser</a>
					</li>
				</ul>

				<ul>
					<li class="nav-item top-level ">
						
						<a href="/developers/">Developers</a>
					</li>
				</ul>

				<ul>
					<li class="nav-item top-level ">
						
						<a href="/dsl/">MDEO DSL</a>
					</li>
				</ul>

				<ul>
					<li class="nav-item top-level ">
						
						<a href="/publications/">Publications</a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/case-studies/default/">Case Studies</a>
							<ul>
								
									<li class="nav-item "><a href="/case-studies/default/">Overview</a></li>
								
									<li class="nav-item "><a href="/case-studies/nrp/">Next Release Problem</a></li>
								
									<li class="nav-item "><a href="/case-studies/argumentation/">One To Many Persuasion Games</a></li>
								
									<li class="nav-item "><a href="/case-studies/cra/">Class Resposability Assignment</a></li>
								
									<li class="nav-item "><a href="/case-studies/resource/">Resource Allocation</a></li>
								
									<li class="nav-item "><a href="/case-studies/scrum/">Scrum Planning</a></li>
								
									<li class="nav-item "><a href="/case-studies/stacks/">Stack</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/mutation_generation/overview/">Mutation Generation</a>
							<ul>
								
									<li class="nav-item "><a href="/mutation_generation/overview/">Overview</a></li>
								
									<li class="nav-item "><a href="/mutation_generation/acpso_generation/">aCPSO Generation</a></li>
								
							</ul>
						</li>
					
				</ul>

				<ul>
					<li class="nav-item top-level ">
						
						<a href="/changelog/">Change Log</a>
					</li>
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<!--<h2>MDEOptimiser</h2>-->
				<h3>Search</h3>
			</div>
			<article class="content">
				<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					

					"case-studies-argumentation": {
						"id": "case-studies-argumentation",
						"title": "One To Many Persuasion Games",
						"category": "",
						"url": " /case-studies/argumentation/",
						"content": "This case study has been submitted for publication at the 7th International Conference on Computational Models of Argument. A link to the final version of the paper will be published as soon as it becomes available. An example implementation using MDEOptimiser can be found in this repository. Introduction Persuasion is the task of inducing the acceptance of a belief in other agents. A political speech is an example of persuasion, in which the politician attempts to persuade the public that their party is the one to vote for at the next election. In this case study we show a one-to-many persuasion setting, where a single persuader broadcasts arguments to a multi-party audience with the aim of convincing them of some goal argument. Since each individual audience member reasons with its own set of personal knowledge (which we assume is known to the persuader) any particular set of persuader arguments may be convincing to some audience members but not others, and so the persuader must carefully select which arguments it should assert in order to maximise the number of audience members it convinces. This is a challenging problem because of the number of potential solutions and the number of audience members to evaluate against: to exhaustively explore the solution space, for each subset of the persuader’s arguments one must consider each audience member and determine whether it would be convinced by those arguments. To efficiently determine the arguments the persuader should assert, i.e., its strategy, we specify the problem using search-based model engineering. By representing the persuasion setting as a meta-model (a schema describing the structure of valid solutions), we can apply evolutionary search to a find a near-optimal strategy for the persuader that maximises the number of convinced audience members. Implementation In the figure above, we show a metamodel of this problem. The goal of this problem is to find a strategy that is effective and efficient. We have specified this problem both as a single-objective and multi-objective problem. In the single-objective case we are only measuring the effectiveness. While in the multi-objective case we are measuring both effecitiveness and efficiency. In the figure below, we show an implementation of the case study using our DSL."
					}

					
				
			
		
			
				
					,
					

					"case-studies-cra": {
						"id": "case-studies-cra",
						"title": "Class Resposability Assignment",
						"category": "",
						"url": " /case-studies/cra/",
						"content": "This case study has been presented at the Transformation Tool Contest 2016 workshop. A link to the final version of the paper with our solution presented there can be found here. An example implementation using MDEOptimiser can be found in this repository. Introduction The Class Responsibility Assignment (CRA) case study has been introduced at the 2016 Transformation Tool Contest. The problem that has to be solved comes from the software engineering field. The goal of this problem is to transform a procedural software application to an object oriented architecture while maintaining good cohesion and coupling. The quality of the produced solutions is measured using the CRA index, as a single objective. The problem supplies a responsibility dependency graph, that contains a set of functions and attributes with dependencies between them. In the metamodel, these entities are instances of the abstract type Feature. The CRA case study authors provide a set of five input models. The difference between them is the number of Features present. Input model A, is the smallest model with only nine features. The largest model provided is model E with 160 features. Across all models, each set of features has an increasing number of dependencies between them. A summary of all the input models is included in the table below.   Model A Model B Model C Model D Model E Attributes 5 10 20 40 80 Methods 4 8 15 40 80 Data Dep. 8 15 50 150 300 Functional Dep. 6 15 50 150 300 Implementation In the figure above, we show a metamodel of this problem. To find a solution, the user is required to create Classes in the ClassModel and assign Features to them such that: all Features are assigned to a Class; the model with the highest CRA index value is found. The problem has an additional constraint requiring that each Feature is assigned to only one Class at a time. We have specified this problem with a single objective: 1. [Objective 1] maximise the CRA index. The problem also has one constraint: 1. [Constraint 1] all Features must be encapsulated in a Class. In the figure below we show an implementation of the case study using our DSL. In our implementation we have used four mutation operators to explore the search space. These have been implemented using Henshin and are shown in the figure below. Automatic mutation generation In the figure below, we include an example of the DSL that allows the user to specify the nodes"
					}

					
				
			
		
			
				
					,
					

					"case-studies-default": {
						"id": "case-studies-default",
						"title": "Overview",
						"category": "",
						"url": " /case-studies/default/",
						"content": "In this section we introduce a list of case studies that have been solved using MDEOptimiser. For each case study we include a brief introduction, followed by a brief implementation description. In our Github repository containing all the implementations you will find all the implementation artifacts along with instructions on how to run them where required."
					}

					
				
			
		
			
				
					,
					

					"case-studies-nrp": {
						"id": "case-studies-nrp",
						"title": "Next Release Problem",
						"category": "",
						"url": " /case-studies/nrp/",
						"content": "An example implementation using MDEOptimiser can be found in this repository. Introduction The aim of the next release problem (NRP) is to find the most suitable set of tasks to include in the next release for a software product, to minimise the cost and to maximise the customer satisfaction. Each Customer has a desire which can consist of one or many SoftwareArtifacts. SoftwareArtifacts can have a dependency on other SoftwareArtifacts. The input models used for this case study have also been automatically generated by the authors using a random model generator implemented using Java. A brief description of these models has been included in the table below. Next Release Problem     Input Model A B Customers 5 25 Requirements 25 50 Software Artifacts 63 203 Implementation In the figure above, we show a metamodel of this problem. To solve this problem, the user is required to assign instances of SoftwareArtifacts to a NextRelease such that the total cost of the selected SoftwareArtifacts is minimised and the total customer satisfaction is maximised. We have specified the problem with the following two objectives: 1. [Objective 1] minimise cost for the selected release itmes; 2. [Objective 2] maximise the customer satisfaction for the proposed release. In the figure below we show an implementation of the case study using our DSL. The minimal set of required rules for this case study is simple, only requiring a mutations to add and remove an edge between a Solution and a SoftwareArtifact. However, the difference between this case study and the others considered so far, is that the selection of a SoftwareArtifact, directly influences the Cost fitness function and indirectly influences the Customer Satisfaction objective. A SoftwareArtifact is considered for the calculation of a RequirementRealization, only when all its dependencies are also assigned to the solution. With this difference, we aim to evaluate how the generated rules explore the search space in cases where the fitness functions provide only coarse-granular guidance. In our implementation we have used four mutation operators to explore the search space. These have been implemented using Henshin and are shown in the figure below. Automatic mutation generation In the figure below, we include an example of the DSL that allows the user to specify the nodes"
					}

					
				
			
		
			
				
					,
					

					"case-studies-resource": {
						"id": "case-studies-resource",
						"title": "Resource Allocation",
						"category": "",
						"url": " /case-studies/resource/",
						"content": "This case study has been presented at the Transformation Tool Contest 2018 workshop. An example implementation using MDEOptimiser can be found in this repository. Introduction This case study is a combinatorial problem covering the combined challenge of software-variant selection and component-resource allocation. It posits a domain where a system architecture is comprised of a number of components, some of which can be used to satisfy certain functional requests to the system. For each component there are one or more implementations. Each implementation may require other components as well as making requirements on resources allocated to the implementation. In addition to providing the component’s functional services, the implementations provide different levels of non-functional quality. To express how they do this, implementations use a simplified form of parametrised contracts, expressing their requirements on resource provision and the non-functional properties provided by used components and, in return, promising to provide a certain level of quality. Implementation In the figure above, we show a metamodel of this problem. The goal of this problem is to find an optimal selection of implementations and allocation of resources so that a set of requests can be satisfied. Requests consist of a component to be called as well as conditions on the quality properties to be provided by this component. The overall objective is expressed as a single objective either summarising or selecting the maximum value of one specific quality property for all requests in a model. We have specified this problem using a single objective: 1. [Objective 1] minimise resource allocation objective; 2. [Objective 2] minimise the non-functional requirements violations by depending implementations; The problem has the following constraints: 1. [Constraint 1] Ensure that all requests are mapped to an implementation; 2. [Constraint 2] Ensure that each component has one implementation only; 3. [Constraint 3] Ensure that each resource is only mapped once; 4. [Constraint 4] Ensure that the request non functional properties are provided by the selected components; 5. [Constraint 5] Ensure that all the request required compoentns are implemented; In the figure below we show an implementation of the case study using our DSL. In our implementation we have used four mutation operators to explore the search space. These have been implemented using Henshin and are shown in the figures below. Change Request Implementation Operator Change Component Mapping Operator Change Resource Mapping Operator Swap Resource Mapping Operator Model initialisation Common operators These operators are rules or units that are reused by other operators in our implementation. Initialisation Unit Cleanup Unit"
					}

					
				
			
		
			
				
					,
					

					"case-studies-scrum": {
						"id": "case-studies-scrum",
						"title": "Scrum Planning",
						"category": "",
						"url": " /case-studies/scrum/",
						"content": "An example CRA case project implemented using MDEOptimiser can be found in this repository. An example implementation using MDEOptimiser can be found in this repository. Introduction Scrum, is a process management framework that proposes the use of fixed time iterations, also called sprints, during which a set of tasks defined as user stories are implemented, tested and released into the product under development. The key artifacts of Scrum are the product, product backlog and the sprint backlog. The product backlog is the list of all user stories that when implemented will result in a completed product. The sprint backlog is the list of user stories which the team aim to complete in a sprint. Each user story has an estimated effort metric associated, also called story points, which denotes the required effort to complete the work. A user story is said to be done after all the development and testing work has been done and the output has been signed off and integrated in the final product. The product owner is in charge of prioritising the backlog to make sure the most important user stories are worked on first. For the duration of a project, the development team completes several sprints. The average number of story points resulting from the completed user stories in a sprint is also known as team velocity. In this case study we will consider that the user stories forming the backlog have an Importance metric, denoting how important they are for a stakeholder, in addition to the Effort metric, which shows the required effort for completion. The product owner is required to prioritise these tasks so that the average stakeholder importance is equally distributed across the sprints required to implement the work items in the backlog. We call this objective the Stakeholder Satisfaction Index and we calculate it as the standard deviation of average stakeholder importance across sprints. Implementation In the figure above, we show a metamodel of this problem. The goal of the problem is to assign WorkItem elements to a number of Sprints with the following objectives: 1. [Objective 1] minimise the Sprint effort deviation; 2. [Objective 2] minimise the Stakeholder Satisfaction Index. The problem also has the following constraints: 1. [Constraint 1] all WorkItem entities must be assigned to a Sprint; 2. [Constraint 2] no solution must have more than a specified maximum number of allowed Sprints. To explore the search space of the Scrum Planning problem, the mutation operators must create Sprint entities and assign WorkItem elements to them, until all the WorkItem elements belong to a Sprint. The solution constraints include a refined multiplicity (with a lower bound of 1) for the sprints edge between a Plan and Sprint and also for the isPlannedFor edge between a WorkItem and a Sprint. In the figure below we show an implementation of the case study using our DSL. In our implementation we have used four mutation operators to explore the search space. These have been implemented using Henshin and are shown in the figure below. Automatic mutation generation In the figure below, we include an example of the DSL that allows the user to specify the nodes"
					}

					
				
			
		
			
				
					,
					

					"case-studies-stacks": {
						"id": "case-studies-stacks",
						"title": "Stack",
						"category": "",
						"url": " /case-studies/stacks/",
						"content": "This case has also been taken from the MOMoT tool website. Introduction The case study is the same as the one described by the MOMoT authors. The only difference is our model based apporach to solve it compared to the rule based approach emplyed by the MOMoT tool."
					}

					
				
			
		
			
				
					,
					

					"mutation-generation-acpso-generation": {
						"id": "mutation-generation-acpso-generation",
						"title": "aCPSO Generation",
						"category": "",
						"url": " /mutation_generation/acpso_generation/",
						"content": "Node Manipulation A list of the supported node manipulation multiplicities is included in the tables below. The first table shows the node creation operators. The second table contains the node deletion operators. Create Node n=0 n=1 and m &gt; n n &gt; 1 and m &gt; n n = m k &gt;= 0 l &gt; k l &lt; * c A Create A add n B (f#l A) Create A lb r single B Create A add n B Create A lb r single B Create A lb r many B Create A add n B (f#l A) k &gt;= 0 l = *   Create A add n B     k = l   Create A lb r single B Create A add n B Create A lb r single B Create A lb r many B N A Delete Node m &gt; n and m &lt; * m = * n = m k = 0 Delete A     k &gt; 0l &gt; k Delete A (require each B still has #k A)     k=l=1 Delete A r lb sg B (f#m A) Delete A r lb sg B N A k=l &gt; 1 Delete A r lb sg B (f#m A) d A r lb mm B (f#m A) Delete A r lb sg B d A r lb mm B N A Edge Manipulation The list of supported multiplicities for generating edge manipulation search operators is included in the tables below. The first table contains the edge creation supported multiplicities and the generated operators. The second table contains the operators generated for edge removal. Edge Creation m &lt; * m = * n=m l &lt; * Add edge NAC A B Add edge NAC B Swap edge l = * Add edge NAC A Add edge Swap edge k = l Change edge (P N A) Change edge (P N A) Swap edge Edge Removal n = 0 n &gt; 0 n = m k = 0 Remove edge Remove edge PAC A Swap Edge k &gt; 0 Remove edge PAC B Remove edge PAC AB Swap Edge k = l Change edge (P N A) Change edge (P N A) Swap Edge"
					}

					
				
			
		
			
				
					,
					

					"mutation-generation-overview": {
						"id": "mutation-generation-overview",
						"title": "Overview",
						"category": "",
						"url": " /mutation_generation/overview/",
						"content": "In this section we describe the mutation generation features implemented in MDEOptimiser. Currently the tool supports only the automatic generation of atomic consistency preserving search operators(aCPSO)."
					}

					
				
			
		
	};
</script>
<script src="/scripts/lunr.min.js"></script>
<script src="/scripts/search.js"></script>

			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
